Пусть ϕ: X → {0, 1} — некоторый предикат, определённый на множестве объектов X. Говорят, что предикат ϕ выделяет или покрывает (cover) объект x, если ϕ(x) = 1. Предикат называют закономерностью, если он выделяет достаточно много объектов какого-то одного класса c, и практически не выделяет объекты других классов.

## Виды интерпретируемых закономерностей
Параметрическое семействоконъюнкций пороговых условий:

<img src="https://github.com/temirkayaeva/ml/blob/main/uAyYf1bQEqdN.png">

Параметрическое семейство синдромных правил:

<img src="https://imagehost7.online-image-editor.com/oie_upload/images/1694218WOBynF2/8Vo3GfZc2niS.png">

Параметрическое семейство шаров:

<img src="https://imagehost7.online-image-editor.com/oie_upload/images/1694341L3C5g/5GQLn43iGC3p.png">

Параметрическое семейство полуплоскостей:

<img src="https://imagehost7.online-image-editor.com/oie_upload/images/1694444oW6tX/SEonLCCHDuow.png">


**Основная проблема — отбор признаков.**

### Логический (эвристический) критерий закономерности

<img src="https://imagehost7.online-image-editor.com/oie_upload/images/16947394EH53jtu/uD6oB9qUb0Qc.png"> 

**Предикат φ(x) —  логическая ε, δ-закономерность класса c∈Y** <img src="https://imagehost7.online-image-editor.com/oie_upload/images/1694959Ee6Xb8D/bfXN46i8HmKM.png">

**Проблема**: хотелось бы иметь один скалярный критерий.

# Решающие списки

Решающий список (decision list, DL) — это наиболее простой логический алгоритм, как по своей структуре, так и по способу построения.

Решающий список — это алгоритм классификации a: X → Y , который задаётся набором закономерностей ϕ1(x),..., ϕT (x), приписанных к классам c1,..., cT ∈ Y соответственно, и вычисляется согласно алгоритму.

1: для всех t = 1,..., T

2: если ϕt(x) = 1 то

3: вернуть ct;

4: вернуть c0.

«Особый ответ» c0 означает отказ алгоритма от классификации объекта x.

## Жадный алгоритм построения решающего списка

Алгоритм на каждой итерации строит ровно одно правило ϕt, выделяющее максимальное число объектов некоторого класса ct и минимальное число объектов всех остальных классов. Для этого на шаге 4 производится поиск наиболее информативного правила ϕt ∈ Φ, допускающего относительно мало ошибок. Семейство правил Φ может быть каким угодно, лишь бы для него существовала эффективная
процедура поиска закономерностей. После построения правила ϕt выделенные им объекты изымаются из выборки и алгоритм переходит к поиску следующего правила ϕt+1 по оставшимся объектам. В итоге выборка оказывается покрытой множествами вида {x: ϕt(x) = 1}. Поэтому решающий список называют также __покрывающим набором закономерностей или машиной покрывающих множеств (set
covering machine, SCM)__.


### Достоинства решающих списков.
• Интерпретируемость и простота классификации. Обученное по выборке правило классификации можно записать в виде инструкции и выполнять «вручную».

• Гибкость: в зависимости от выбора множества Φ можно строить весьма разнообразные алгоритмические конструкции.

• Возможность обработки разнотипных данных и данных с пропусками.

### Недостатки решающих списков.
• Если множество правил Φ выбрано неудачно, список может не построиться. При этом возможен высокий процент отказов от классификации.

• Возможна утрата интерпретируемости, если список длинный и правила различных классов следуют вперемежку. В этом случае правила не могут быть интерпретированы по-отдельности, без учёта предшествующих правил, и логика их взаимодействия становится довольно запутанной.

• Каждый объект классифицируется только одним правилом, что не позволяет
правилам компенсировать неточности друг друга. Данный недостаток устраняется путём голосования правил, но это уже совсем другой алгоритм.


## Решающие деревья

*Деревом* называется конечный связный граф с множеством вершин V , не содержащий циклов и имеющий выделенную вершину v0 ∈ V , в которую не входит ни одно ребро. Эта вершина называется *корнем* дерева. Вершина, не имеющая выходящих рёбер, называется *терминальной или листом*. Остальные вершины называются внутренними. Дерево называется *бинарным*, если из любой его внутренней вершины выходит ровно два ребра. Выходящие рёбра связывают каждую внутреннюю вершину v с *левой дочерней вершиной* Lv и с *правой дочерней вершиной* Rv.

**Бинарное решающее дерево** — это алгоритм классификации, задающийся бинарным деревом, в котором каждой внутренней вершине v ∈ V приписан предикат βv : X → {0, 1}, каждой терминальной вершине v ∈ V приписано имя класса cv ∈ Y . При классификации объекта x ∈ X он проходит по дереву путь от корня до некоторого листа, в соответствии с алгоритмом.

1: v := v0;

2: пока вершина v внутренняя

3: если βv(x) = 1 то

4: v := Rv; (переход вправо)

5: иначе

6: v := Lv; (переход влево)

7: вернуть cv.

Решающее дерево никогда не отказывается от классификации, в отличие от решающего списка. Отсюда также следует, что алгоритм классификации a: X → Y , реализуемый бинарным решающим деревом, можно представить в виде простого голосования конъюнкций.
