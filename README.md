## Определение закономерности 

Закономерность (правило, rule) — это предикат ϕ: X → {0, 1}, удовлетворяющий двум требованиям:

1) интерпретируемость (ϕ зависит от 1–7 признаков);
2) информативность относительно класса c ∈ Y :

<img src="https://github.com/temirkayaeva/ml/blob/main/1.png">

**Если ϕ(x) = 1, то говорят «ϕ выделяет x» (ϕ covers x).**

Закономерность — это хорошо интерпретируемый одноклассовый классификатор с отказами.


## Виды интерпретируемых закономерностей
Параметрическое семействоконъюнкций пороговых условий:

<img src="https://github.com/temirkayaeva/ml/blob/main/1(1).png">

Параметрическое семейство синдромных правил:

<img src="https://github.com/temirkayaeva/ml/blob/main/2.png">

Параметрическое семейство шаров:

<img src="https://github.com/temirkayaeva/ml/blob/main/3.png">

Параметрическое семейство полуплоскостей:

<img src="https://github.com/temirkayaeva/ml/blob/main/4.png">


**Основная проблема — отбор признаков.**

### Логический (эвристический) критерий закономерности

<img src="https://github.com/temirkayaeva/ml/blob/main/5.png">

**Предикат φ(x) —  логическая ε, δ-закономерность класса c∈Y** 

<img src="https://github.com/temirkayaeva/ml/blob/main/6.png">

**Проблема**: хотелось бы иметь один скалярный критерий.

### Статистический критерий информативности

**Точный тест Фишера.** ПустьX — в.п., выборка Xℓ — i.i.d.

Гипотеза H0: y(x) и φ(x) — независимые случайные величины. Тогда вероятность реализации пары (p,n) описывается гипергеометрическим распределением:

<img src="https://github.com/temirkayaeva/ml/blob/main/7.png">

### Энтропийный критерий информативности

Пусть ω0, ω1 — два исхода с вероятностями q и 1 − q. Количество информации: I0 = − log2 q, I1 = − log2(1 − q). Энтропия — математическое ожидание количества информации: h(q) = −qlog2q − (1 − q) log2 (1 − q).

Энтропия выборки Xℓ, если исходы — это классы

<img src="https://github.com/temirkayaeva/ml/blob/main/8.png">

Энтропия выборки Xℓ после получения информации ϕ:

<img src="https://github.com/temirkayaeva/ml/blob/main/9.png">

### Задача перебора конъюнкций

Пусть B — конечное множество элементарных предикатов, например, вида <img src="https://github.com/temirkayaeva/ml/blob/main/10.png">

Множество конъюнкций с ограниченным числом термов из B: 

<img src="https://github.com/temirkayaeva/ml/blob/main/11.png">

#### Семейство методов локального поиска

Окрестность V (ϕ) — все конъюнкции, получаемые из ϕ добавлением, изъятием или модификацией одного из термов.

**Основная идея:** на t-й итерации

<img src="https://github.com/temirkayaeva/ml/blob/main/12.png">

#### Обобщённый алгоритм локального поиска

<img src="https://github.com/temirkayaeva/ml/blob/main/13.png">

#### Частные случаи и модификации

* жадный алгоритм: V (ϕ) — только добавления термов; ϕ0 = ∅;

* стохастический локальный поиск (SLS): V (ϕ) — случайное подмножество всевозможных добавлений, удалений, модификаций термов; ϕ0 = ∅;

* стабилизация: V (ϕ) — удаления термов или изменение параметров в термах; ϕ0 не равно ∅;

* редукция: V (ϕ) — только удаления термов; ϕ0 не равно ∅; Ic (ϕ,Xk) оценивается по контрольной выборке Xk;

* поиск в ширину: на каждой итерации строится множество конъюнкций Φt = {ϕt}.

# Решающие списки

Решающий список (decision list, DL) — это наиболее простой логический алгоритм, как по своей структуре, так и по способу построения.

Решающий список (decision list, DL) — алгоритм классификации a : X → Y , который задаётся закономерностями ϕ1(x), . . . , ϕT (x) классов c1, . . . , cT ∈ Y :

1: для всех t = 1,..., T

2: если ϕt(x) = 1 то

3: вернуть ct;

4: вернуть c0.

«Особый ответ» c0 означает отказ алгоритма от классификации объекта x.

<img src="https://github.com/temirkayaeva/ml/blob/main/14.png">

### Построение решающего списка

<img src="https://github.com/temirkayaeva/ml/blob/main/15.png">


### Достоинства:

* Интерпретируемость и простота классификации.

* Универсальность: можно использовать любое семейство Φ.

* Допустимы разнотипные данные и данные с пропусками.

* Правила получаются различными. Можно построить несколько списков и по ним проголосовать.

### Недостатки

* При неудачном выборе Φ список может не построиться, будет много отказов от классификации.

* Список плохо интерпретируется, если он длинный и/или правила различных классов следуют вперемежку.

* Качество классификации обычно ниже, чем у голосования, когда правила могут компенсировать ошибки друг друга.

## Определение бинарного решающего дерева

Бинарное решающее дерево — алгоритм классификации a(x), задающийся бинарным деревом:

<img src="https://github.com/temirkayaeva/ml/blob/main/16.png">


## Решающие деревья

*Деревом* называется конечный связный граф с множеством вершин V , не содержащий циклов и имеющий выделенную вершину v0 ∈ V , в которую не входит ни одно ребро. Эта вершина называется *корнем* дерева. Вершина, не имеющая выходящих рёбер, называется *терминальной или листом*. Остальные вершины называются внутренними. Дерево называется *бинарным*, если из любой его внутренней вершины выходит ровно два ребра. Выходящие рёбра связывают каждую внутреннюю вершину v с *левой дочерней вершиной* Lv и с *правой дочерней вершиной* Rv.

**Бинарное решающее дерево** — это алгоритм классификации, задающийся бинарным деревом, в котором каждой внутренней вершине v ∈ V приписан предикат βv : X → {0, 1}, каждой терминальной вершине v ∈ V приписано имя класса cv ∈ Y . При классификации объекта x ∈ X он проходит по дереву путь от корня до некоторого листа, в соответствии с алгоритмом.

1: v := v0;

2: пока вершина v внутренняя

3: если βv(x) = 1 то

4: v := Rv; (переход вправо)

5: иначе

6: v := Lv; (переход влево)

7: вернуть cv.

Решающее дерево никогда не отказывается от классификации, в отличие от решающего списка. Отсюда также следует, что алгоритм классификации a: X → Y , реализуемый бинарным решающим деревом, можно представить в виде простого голосования конъюнкций.
