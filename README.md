## Определение закономерности 

Закономерность (правило, rule) — это предикат ϕ: X → {0, 1}, удовлетворяющий двум требованиям:

1) интерпретируемость (ϕ зависит от 1–7 признаков);
2) информативность относительно класса c ∈ Y :

<img src="https://github.com/temirkayaeva/ml/blob/main/1.png">

**Если ϕ(x) = 1, то говорят «ϕ выделяет x» (ϕ covers x).**

Закономерность — это хорошо интерпретируемый одноклассовый классификатор с отказами.


## Виды интерпретируемых закономерностей
Параметрическое семействоконъюнкций пороговых условий:

<img src="https://github.com/temirkayaeva/ml/blob/main/1(1).png">

Параметрическое семейство синдромных правил:

<img src="https://github.com/temirkayaeva/ml/blob/main/2.png">

Параметрическое семейство шаров:

<img src="https://github.com/temirkayaeva/ml/blob/main/3.png">

Параметрическое семейство полуплоскостей:

<img src="https://github.com/temirkayaeva/ml/blob/main/4.png">


**Основная проблема — отбор признаков.**

### Логический (эвристический) критерий закономерности

<img src="https://github.com/temirkayaeva/ml/blob/main/5.png">

**Предикат φ(x) —  логическая ε, δ-закономерность класса c∈Y** <img src="https://github.com/temirkayaeva/ml/blob/main/6.png">

**Проблема**: хотелось бы иметь один скалярный критерий.

### Статистический критерий информативности

**Точный тест Фишера.** ПустьX — в.п., выборка Xℓ — i.i.d.

Гипотеза H0: y(x) и φ(x) — независимые случайные величины. Тогда вероятность реализации пары (p,n) описывается гипергеометрическим распределением:

<img src="https://github.com/temirkayaeva/ml/blob/main/7.png">

### Энтропийный критерий информативности

Пусть ω0, ω1 — два исхода с вероятностями q и 1 − q. Количество информации: I0 = − log2 q, I1 = − log2(1 − q). Энтропия — математическое ожидание количества информации: h(q) = −qlog2q − (1 − q) log2 (1 − q).

Энтропия выборки Xℓ, если исходы — это классы

<img src="https://github.com/temirkayaeva/ml/blob/main/8.png">

Энтропия выборки Xℓ после получения информации ϕ:

<img src="https://github.com/temirkayaeva/ml/blob/main/9.png">

### Задача перебора конъюнкций

Пусть B — конечное множество элементарных предикатов, например, вида <img src="https://github.com/temirkayaeva/ml/blob/main/10.png">

Множество конъюнкций с ограниченным числом термов из B: 

<img src="https://github.com/temirkayaeva/ml/blob/main/11.png">

#### Семейство методов локального поиска

Окрестность V (ϕ) — все конъюнкции, получаемые из ϕ добавлением, изъятием или модификацией одного из термов.

**Основная идея:** на t-й итерации

<img src="https://github.com/temirkayaeva/ml/blob/main/12.png">

#### Обобщённый алгоритм локального поиска

<img src="https://github.com/temirkayaeva/ml/blob/main/13.png">

# Решающие списки

Решающий список (decision list, DL) — это наиболее простой логический алгоритм, как по своей структуре, так и по способу построения.

Решающий список — это алгоритм классификации a: X → Y , который задаётся набором закономерностей ϕ1(x),..., ϕT (x), приписанных к классам c1,..., cT ∈ Y соответственно, и вычисляется согласно алгоритму.

1: для всех t = 1,..., T

2: если ϕt(x) = 1 то

3: вернуть ct;

4: вернуть c0.

«Особый ответ» c0 означает отказ алгоритма от классификации объекта x.

## Жадный алгоритм построения решающего списка

Алгоритм на каждой итерации строит ровно одно правило ϕt, выделяющее максимальное число объектов некоторого класса ct и минимальное число объектов всех остальных классов. Для этого на шаге 4 производится поиск наиболее информативного правила ϕt ∈ Φ, допускающего относительно мало ошибок. Семейство правил Φ может быть каким угодно, лишь бы для него существовала эффективная
процедура поиска закономерностей. После построения правила ϕt выделенные им объекты изымаются из выборки и алгоритм переходит к поиску следующего правила ϕt+1 по оставшимся объектам. В итоге выборка оказывается покрытой множествами вида {x: ϕt(x) = 1}. Поэтому решающий список называют также __покрывающим набором закономерностей или машиной покрывающих множеств (set
covering machine, SCM)__.


### Достоинства решающих списков.
• Интерпретируемость и простота классификации. Обученное по выборке правило классификации можно записать в виде инструкции и выполнять «вручную».

• Гибкость: в зависимости от выбора множества Φ можно строить весьма разнообразные алгоритмические конструкции.

• Возможность обработки разнотипных данных и данных с пропусками.

### Недостатки решающих списков.
• Если множество правил Φ выбрано неудачно, список может не построиться. При этом возможен высокий процент отказов от классификации.

• Возможна утрата интерпретируемости, если список длинный и правила различных классов следуют вперемежку. В этом случае правила не могут быть интерпретированы по-отдельности, без учёта предшествующих правил, и логика их взаимодействия становится довольно запутанной.

• Каждый объект классифицируется только одним правилом, что не позволяет
правилам компенсировать неточности друг друга. Данный недостаток устраняется путём голосования правил, но это уже совсем другой алгоритм.


## Решающие деревья

*Деревом* называется конечный связный граф с множеством вершин V , не содержащий циклов и имеющий выделенную вершину v0 ∈ V , в которую не входит ни одно ребро. Эта вершина называется *корнем* дерева. Вершина, не имеющая выходящих рёбер, называется *терминальной или листом*. Остальные вершины называются внутренними. Дерево называется *бинарным*, если из любой его внутренней вершины выходит ровно два ребра. Выходящие рёбра связывают каждую внутреннюю вершину v с *левой дочерней вершиной* Lv и с *правой дочерней вершиной* Rv.

**Бинарное решающее дерево** — это алгоритм классификации, задающийся бинарным деревом, в котором каждой внутренней вершине v ∈ V приписан предикат βv : X → {0, 1}, каждой терминальной вершине v ∈ V приписано имя класса cv ∈ Y . При классификации объекта x ∈ X он проходит по дереву путь от корня до некоторого листа, в соответствии с алгоритмом.

1: v := v0;

2: пока вершина v внутренняя

3: если βv(x) = 1 то

4: v := Rv; (переход вправо)

5: иначе

6: v := Lv; (переход влево)

7: вернуть cv.

Решающее дерево никогда не отказывается от классификации, в отличие от решающего списка. Отсюда также следует, что алгоритм классификации a: X → Y , реализуемый бинарным решающим деревом, можно представить в виде простого голосования конъюнкций.
